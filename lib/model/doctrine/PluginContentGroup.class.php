<?php

/**
 * ContentGroup
 *
 * This class has been auto-generated by the Doctrine ORM Framework
 *
 * @package    site_cms
 * @subpackage model
 * @author     Jo Carter
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
abstract class PluginContentGroup extends BaseContentGroup
{
	/**
	 * Use getContentGroupType() to access this
	 *
	 * @var ContentGroupType
	 */
	protected $typeObj = null;

	/**
	 * @var string
	 */
	protected $currentLang = null;

	/**
	 * Cached Content block definitions
	 *
	 * @var array
	 */
	protected $blockDefinitions = null;

	/**
	 * Create a new Content group for the given type.
	 * Does not check that the type is valid.
	 *
	 * @param string $type
	 * @return ContentGroup
	 */
	public static function createNew($type, $typeOptions='')
	{
		$group = new ContentGroup();
		$group->type = $type;
		$group->type_options = $typeOptions;
		$group->save();

		return $group;
	}

	/**
	 * Set the current language.
	 * Does not check that it's valid
	 *
	 * @param string $v
	 */
	public function setCurrentLang($v)
	{
		$this->currentLang = $v;
	}

	/**
	 * Get the current lang.  This needs to be set before the Content block
	 * group can be used properly.
	 *
	 * @return string
	 */
	public function getCurrentLang()
	{
		if ($this->currentLang === null)
		{
			throw new sfException("You must set the current language before you can use this Content group.");
		}
		return $this->currentLang;
	}

	/**
	 * @return ContentGroupType
	 */
	public function getContentGroupType()
	{
		if ($this->typeObj === null)
		{
			$class = 'ContentGroupType' . $this->type;

			if (!class_exists($class))
			{
				throw new sfException("There is no type class, " . $class);
			}

			$typeObj = new $class();
			$typeObj->setContentGroup($this);
			$this->typeObj = $typeObj;
		}

		return $this->typeObj;
	}

	/**
	 * Get the Content blocks from this Content group in the order they
	 * are in the definition array.
	 *
	 * It also initialises the group.
	 */
	public function getOrderedBlocks($checkBlockDefinitions = false)
	{
		$this->initialiseBlocks($checkBlockDefinitions);
		$contentBlocks = $this->ContentBlocks;

		// make array indexed by identifier
		$blocksByIdentifier = array();

		if (!empty($contentBlocks))
		{
			foreach ($contentBlocks as $contentBlock)
			{
				$blocksByIdentifier[$contentBlock->identifier] = $contentBlock;
			}
		}

		// make ordered array
		$orderedBlocks = array();

		foreach ($this->getBlockDefinitions() as $identifier => $defn)
		{
			$contentBlock = $blocksByIdentifier[$identifier];
			$contentBlock->ContentGroup = $this;
			$orderedBlocks[$identifier] = $contentBlock;
		}

		return $orderedBlocks;
	}

	/**
	 * Initialises the Content blocks for this group, that is:
	 *  - Looks at Content block definitions for this group
	 *  - Loads up Content blocks from database and makes sure they match (creates if necessary)
	 *
	 * After calling this, $this->ContentBlocks can be used reliably.
	 */
	public function initialiseBlocks($checkBlockDefinitions = false)
	{
		$blockDefinitions = $this->getBlockDefinitions($checkBlockDefinitions);
		$currentBlocks = $this->getContentBlocks();

		// get identifiers of current Content blocks
		$currentBlockIdentifiers = array();
		if (!empty($currentBlocks))
		{
			foreach ($currentBlocks as $contentBlock)
			{
				$currentBlockIdentifiers[] = $contentBlock->identifier;
			}
		}

		// get identifiers from block definitions
		$intendedBlockIdentifiers = array();
		if (!empty($blockDefinitions))
		{
			foreach ($blockDefinitions as $blockDefinition)
			{
				$intendedBlockIdentifiers[] = $blockDefinition['identifier'];
			}
		}

		// create new Content blocks for new template
		if (count($identifiersToCreate = array_diff($intendedBlockIdentifiers, $currentBlockIdentifiers)) > 0)
		{
			$this->createBlocks($identifiersToCreate);
		}

		// check current Content block matches definition
		if (count($identifiersToCheck = array_intersect($intendedBlockIdentifiers, $currentBlockIdentifiers)) > 0)
		{
			$this->checkBlocks($identifiersToCheck);
		}

		// remove old Content blocks - i.e changed template
		if (count($identifiersToRemove = array_diff($currentBlockIdentifiers, $intendedBlockIdentifiers)) > 0)
		{
			$this->removeBlocks($identifiersToRemove);
		}
	}

	/**
	 * Get an array of Content block definitions for this group
	 */
	public function getBlockDefinitions($checkBlockDefinitions = false)
	{
		if (!$this->blockDefinitions)
		{
			$definitions = $this->getContentGroupType()->getContentBlockDefinitions();

			if (!empty($definitions))
			{
				foreach ($definitions as $identifier => $definition)
				{
					$definitions[$identifier] = $this->tidyBlockDefinition($identifier, $definition);
				}
			}
			else
			{
				// No Content blocks for page
				$definitions = array();
			}

			$this->blockDefinitions = $definitions;
		}

		if ($checkBlockDefinitions)
		{
			foreach ($this->blockDefinitions as $identifier => $definition)
			{
				$this->checkBlockDefinition($identifier, $definition);
			}
		}

		return $this->blockDefinitions;
	}

	/**
	 * Tidy block definitions up
	 *
	 * @param string $identifier
	 * @param array $definition
	 * @return array
	 */
	public function tidyBlockDefinition($identifier, $definition)
	{
		if (!isset($definition['identifier']))
		{
			$definition['identifier'] = $identifier;
		}

		return $definition;
	}

	/**
	 * Check that block definitions are okay.
	 * Used in the backend to warn developers.
	 *
	 * @param string $identifier
	 * @param array $definition
	 */
	public function checkBlockDefinition($identifier, $definition)
	{
		if (strlen($identifier) < 2 || strlen($identifier) > 50)
		{
			throw new sfException("Identifier must be between 2 and 50 characters long");
		}

		if ($definition['identifier'] != $identifier)
		{
			throw new sfException("Identifier in definition must match identifier from array key");
		}

		if (!isset($definition['name']))
		{
			throw new sfException("You must provide a name");
		}
	}

	/**
	 * Create Content blocks for the given $identifiers
	 *
	 * @param array[string] $identifiers
	 */
	public function createBlocks($identifiers)
	{
		foreach ($identifiers as $identifier)
		{
			$this->createBlockForIdentifier($identifier);
		}
	}

	/**
	 * Create a Content block for the given identifier.
	 * @todo Does not check that this Content block does not already exist.
	 *
	 * @param string $identifier
	 */
	public function createBlockForIdentifier($identifier)
	{
		$contentBlock = ContentBlock::createFromIdentifier($identifier, $this);
		$this->ContentBlocks[] = $contentBlock;
	}

	/**
	 * Check Content blocks for the given $identifiers against their definitions
	 *
	 * @param array[string] $identifiers
	 */
	public function checkBlocks($identifiers)
	{
		foreach ($identifiers as $identifier)
		{
			$this->checkBlockForIdentifier($identifier);
		}
	}

	/**
	 * Checks that the Content block for this identifier is the same type as the definition
	 *
	 * @param string $identifier
	 */
	public function checkBlockForIdentifier($identifier)
	{
		$contentBlock = $this->getBlockByIdentifier($identifier);
		$definition = $this->getBlockDefinition($contentBlock);

		if ($contentBlock->type != $definition['type'])
		{
			// The type of the Content block in the database is not the correct type.
			// we must delete it and make another
			$this->removeBlockForIdentifier($identifier);
			$this->createBlockForIdentifier($identifier);
		}
	}

	/**
	 * Remove Content blocks for the given $identifiers
	 *
	 * @param array[string] $identifiers
	 */
	public function removeBlocks($identifiers)
	{
		foreach ($identifiers as $identifier)
		{
			$this->removeBlockForIdentifier($identifier);
		}
	}

	/**
	 * Remove a Content block for the given identifier.
	 *
	 * @param string $identifier
	 */
	public function removeBlockForIdentifier($identifier)
	{
		foreach ($this->ContentBlocks as $key => $contentBlock)
    {
      if ($contentBlock->identifier == $identifier)
      {
        // delete the current version stuff
        $allCVersions = $contentBlock->CurrentVersions;
        foreach ($allCVersions as $cVersion)
        {
          $cVersion->delete();
          $cVersion->free();
        }
        
        // delete all of the ContentBlock versions
        $allVersions = $contentBlock->Versions;
        foreach ($allVersions as $version)
        {
          $version->delete();
          $version->free();
        }
  
        $this->ContentBlocks->remove($key);
        $contentBlock->delete();
        $contentBlock->free();

        return;
      }
		}
	}

	/**
	 * Get the definition array for the given Content block
	 *
	 * @param mixed $blockOrIdentifier
	 * @return array
	 */
	public function getBlockDefinition($blockOrIdentifier)
	{
		if ($blockOrIdentifier instanceof ContentBlock)
		{
			$identifier = $blockOrIdentifier->identifier;
		}
		else
		{
			$identifier = $blockOrIdentifier;
		}

		$blockDefinitions = $this->getBlockDefinitions();
		foreach ($blockDefinitions as $definition)
		{
			if ($definition['identifier'] == $identifier)
			{
				return $definition;
			}
		}

		return null;
	}

	/**
	 * Get a Content block by its identifier
	 *
	 * @param string $identifier
	 * @return ContentBlock
	 */
	public function getBlockByIdentifier($identifier)
	{
		foreach ($this->ContentBlocks as $contentBlock)
		{
			if ($contentBlock->identifier == $identifier)
			{
				return $contentBlock;
			}
		}

		return null;
	}

	/**
	 * Initialise the Content blocks for rendering
	 *
	 * Does not load up Content blocks/current versions at all - use
	 * loadAllContentBlocksForRender() to load all of the data in one query.
	 *
	 * @see loadAllContentBlocksForRender()
	 * @param string $lang
	 */
	public function initialiseForRender($lang)
	{
		$this->setCurrentLang($lang);
	}

	/**
	 * Load Content blocks and current versions for rendering
	 */
	public function loadAllContentBlocksForRender()
	{
		$lang = $this->getCurrentLang();
		$contentBlocks = ContentBlockTable::getInstance()->loadAllCurrentVersions($this->id, $lang);

		foreach ($contentBlocks as $contentBlock)
		{
			// We have to link the ContentBlock back to this group - it needs to know about the group for its definition
			$contentBlock->ContentGroup = $this;

			// We have constructed the query so that Versions just contains the current version
			$currentContentBlockVersion = $contentBlock->Versions->getFirst();

			// The ContentBlockVersion needs to be linked back to the ContentBlock, as it gets its definitions from there
			$currentContentBlockVersion->ContentBlock = $contentBlock;
			$contentBlockLang = $contentBlock->getCurrentLang();

			// By setting this, the ContentBlock will not need to do an additional DB query to load its current version.
			$contentBlock->setCurrentVersionsCache($currentContentBlockVersion, $contentBlockLang);
		}

		$this->ContentBlocks = $contentBlocks;
	}

	/**
	 * Render a Content block
	 *
	 * @param string $identifier
	 * @param array $extraParams
	 * @return string
	 */
	public function renderContent($identifier, $extraParams = array())
	{
		if (!$contentBlock = $this->getBlockByIdentifier($identifier))
		{
			return '';
		}

		if (!$contentBlockVersion = $contentBlock->getCurrentVersion())
		{
			return '';
		}

		$contentBlockVersion->mergeParameters($extraParams);

		if (siteManager::getInstance()->getRenderFromRequest())
		{
			// we are in preview mode - render from the request
			$request = sfContext::getInstance()->getRequest();

			return $contentBlockVersion->getContentBlockType()->renderFromRequest($request);
		}
		else
		{
			return $contentBlockVersion->getContentBlockType()->render();
		}
	}

	/**
	 * Delete this Content group and all associated Content
	 *
	 * @param Doctrine_Connection $conn
	 */
	public function delete(Doctrine_Connection $conn = null)
	{
		foreach ($this->ContentBlocks as $contentBlock)
		{
		  // delete the current version stuff
      $allCVersions = $contentBlock->CurrentVersions;
      foreach ($allCVersions as $cVersion)
      {
        $cVersion->delete();
        $cVersion->free();
      }
		  
			// delete all of the ContentBlock versions
			$allVersions = $contentBlock->Versions;
			foreach ($allVersions as $version)
			{
				$version->delete();
				$version->free();
			}

			// finally, delete the ContentBlock itself
			$contentBlock->delete();
			$contentBlock->free();
		}

		parent::delete($conn);
	}
}
