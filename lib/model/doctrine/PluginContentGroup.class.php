<?php

/**
 * ContentGroup
 * 
 * This class has been auto-generated by the Doctrine ORM Framework
 * 
 * @package    site_cms
 * @subpackage model
 * @author     Jo Carter
 * @version    SVN: $Id: Builder.php 7490 2010-03-29 19:53:27Z jwage $
 */
abstract class PluginContentGroup extends BaseContentGroup 
{	
	/**
     * Use getContentGroupType() to access this
     *
     * @var ContentGroupType
     */
    protected $typeObj = null;

    /**
     * @var string
     */
    protected $currentLang = null;

    /**
     * Cached Content block definitions
     *
     * @var array
     */
    protected $blockDefinitions = null;
    
    /**
     * Create a new Content group for the given type.
     * Does not check that the type is valid.
     *
     * @param string $type
     * @return ContentGroup
     */
    public static function createNew($type, $typeOptions='') 
	{
        $group = new ContentGroup();
        $group->type = $type;
        $group->type_options = $typeOptions;
        $group->save();

        return $group;
    }
    
    /**
     * Set the current language.
     * Does not check that it's valid
     *
     * @param string $v
     */
    public function setCurrentLang($v) 
	{
        $this->currentLang = $v;
    }
    
   /**
     * Get the current lang.  This needs to be set before the Content block
     * group can be used properly.
     *
     * @return string
     */
    public function getCurrentLang() 
	{
        if ($this->currentLang === null) 
		{
            throw new sfException("You must set the current language before you can use this Content group.");
        }
        return $this->currentLang;
    }
	
	/**
     * @return ContentGroupType
     */
    public function getContentGroupType() 
	{
        if ($this->typeObj === null) 
		{
            $class = 'ContentGroupType' . $this->type;

            if (!class_exists($class)) 
			{
                throw new sfException("There is no type class, " . $class);
            }

            $typeObj = new $class();
            $typeObj->setContentGroup($this);
            $this->typeObj = $typeObj;
        }

        return $this->typeObj;
    }
    
	/**
     * Get the Content blocks from this Content group in the order they
     * are in the definition array.
     *
     * It also initialises the group.
     */
    public function getOrderedBlocks($checkBlockDefinitions = false) 
	{
        $this->initialiseBlocks($checkBlockDefinitions);
        $contentBlocks = $this->ContentBlocks;

        // make array indexed by identifier
        $blocksByIdentifier = array();
        
        if (!empty($contentBlocks)) 
		{
	        foreach ($contentBlocks as $contentBlock) 
			{
	            $blocksByIdentifier[$contentBlock->identifier] = $contentBlock;
	        }
        }

        // make ordered array
        $orderedBlocks = array();
        
        foreach ($this->getBlockDefinitions() as $identifier => $defn) 
		{
            $contentBlock = $blocksByIdentifier[$identifier];
            $contentBlock->ContentGroup = $this;
            $orderedBlocks[$identifier] = $contentBlock;
        }

        return $orderedBlocks;
    }
    
    /**
     * Initialises the Content blocks for this group, that is:
     *  - Looks at Content block definitions for this group
     *  - Loads up Content blocks from database and makes sure they match (creates if necessary)
     *
     * After calling this, $this->ContentBlocks can be used reliably.
     */
    public function initialiseBlocks($checkBlockDefinitions = false) 
	{
        $blockDefinitions = $this->getBlockDefinitions($checkBlockDefinitions);
        $currentBlocks = $this->getContentBlocks();

        // get identifiers of current Content blocks
        $currentBlockIdentifiers = array();
        if (!empty($currentBlocks)) 
		{
	        foreach ($currentBlocks as $contentBlock) 
			{
	            $currentBlockIdentifiers[] = $contentBlock->identifier;
	        }
        }

        // get identifiers from block definitions
        $intendedBlockIdentifiers = array();
        if (!empty($blockDefinitions)) 
		{
	        foreach ($blockDefinitions as $blockDefinition) 
			{
	            $intendedBlockIdentifiers[] = $blockDefinition['identifier'];
	        }
        }
        
        // create new Content blocks for new template
        if (count($identifiersToCreate = array_diff($intendedBlockIdentifiers, $currentBlockIdentifiers)) > 0) 
		{
            $this->createBlocks($identifiersToCreate);
        }
        
        // check current Content block matches definition
        if (count($identifiersToCheck = array_intersect($intendedBlockIdentifiers, $currentBlockIdentifiers)) > 0) 
		{
            $this->checkBlocks($identifiersToCheck);
        }
        
        // remove old Content blocks - i.e changed template
        if (count($identifiersToRemove = array_diff($currentBlockIdentifiers, $intendedBlockIdentifiers)) > 0) 
		{
            $this->removeBlocks($identifiersToRemove);
        }
    }

    /**
     * Get an array of Content block definitions for this group
     */
    public function getBlockDefinitions($checkBlockDefinitions = false) 
	{
        if (!$this->blockDefinitions) 
		{
            $definitions = $this->getContentGroupType()->getContentBlockDefinitions();
            
            if (!empty($definitions)) 
			{
              foreach ($definitions as $identifier => $definition) 
			  {
                  $definitions[$identifier] = $this->tidyBlockDefinition($identifier, $definition);
              }
            }
            else 
			{
            	// No Content blocks for page
            	$definitions = array();
            }
            
            $this->blockDefinitions = $definitions;
        }

        if ($checkBlockDefinitions) 
		{
            foreach ($this->blockDefinitions as $identifier => $definition) 
			{
                $this->checkBlockDefinition($identifier, $definition);
            }
        }

        return $this->blockDefinitions;
    }
    
	/**
     * Tidy block definitions up
     *
     * @param string $identifier
     * @param array $definition
     * @return array
     */
    public function tidyBlockDefinition($identifier, $definition) 
	{
        if (!isset($definition['identifier'])) 
		{
            $definition['identifier'] = $identifier;
        }
        
        return $definition;
    }

    /**
     * Check that block definitions are okay.
     * Used in the backend to warn developers.
     *
     * @param string $identifier
     * @param array $definition
     */
    public function checkBlockDefinition($identifier, $definition) 
	{
        if (strlen($identifier) < 2 || strlen($identifier) > 50) 
		{
            throw new sfException("Identifier must be between 2 and 50 characters long");
        }
        
        if ($definition['identifier'] != $identifier) 
		{
            throw new sfException("Identifier in definition must match identifier from array key");
        }
        
        if (!isset($definition['name'])) 
		{
            throw new sfException("You must provide a name");
        }
    }
    
    /**
     * Create Content blocks for the given $identifiers
     * 
     * @param array[string] $identifiers
     */
    public function createBlocks($identifiers) 
	{
        foreach ($identifiers as $identifier) 
		{
            $this->createBlockForIdentifier($identifier);
        }
    }

    /**
     * Create a Content block for the given identifier.
     * @todo Does not check that this Content block does not already exist.
     *
     * @param string $identifier
     */
    public function createBlockForIdentifier($identifier) 
	{
        $contentBlock = ContentBlock::createFromIdentifier($identifier, $this);
        $this->ContentBlocks[] = $contentBlock;
    }

    /**
     * Check Content blocks for the given $identifiers against their definitions
     * 
     * @param array[string] $identifiers
     */
    public function checkBlocks($identifiers) 
	{
        foreach ($identifiers as $identifier) 
		{
            $this->checkBlockForIdentifier($identifier);
        }
    }

    /**
     * Checks that the Content block for this identifier is the same type as the definition
     *
     * @param string $identifier
     */
    public function checkBlockForIdentifier($identifier) 
	{
        $contentBlock = $this->getBlockByIdentifier($identifier);
        $definition = $this->getBlockDefinition($contentBlock);

        if ($contentBlock->type != $definition['type']) 
		{
            // The type of the Content block in the database is not the correct type.
            // we must delete it and make another
            $this->removeBlockForIdentifier($identifier);
            $this->createBlockForIdentifier($identifier);
        }
    }

    /**
     * Remove Content blocks for the given $identifiers
     * 
     * @param array[string] $identifiers
     */
    public function removeBlocks($identifiers) 
	{
        foreach ($identifiers as $identifier) 
		{
            $this->removeBlockForIdentifier($identifier);
        }
    }

    /**
     * Remove a Content block for the given identifier.
     *
     * @param string $identifier
     */
    public function removeBlockForIdentifier($identifier) 
	{
        foreach ($this->ContentBlocks as $key => $contentBlock) 
		{
            if ($contentBlock->identifier == $identifier) 
			{
                $this->ContentBlocks->remove($key);
                $contentBlock->delete();
                $contentBlock->free();
                
                return;
            }
        }
    }
    
	/**
     * Get the definition array for the given Content block
     *
     * @param mixed $blockOrIdentifier
     * @return array
     */
    public function getBlockDefinition($blockOrIdentifier) 
	{
        if ($blockOrIdentifier instanceof ContentBlock) 
		{
            $identifier = $blockOrIdentifier->identifier;
        } 
		else 
		{
            $identifier = $blockOrIdentifier;
        }

        $blockDefinitions = $this->getBlockDefinitions();
        foreach ($blockDefinitions as $definition) 
		{
            if ($definition['identifier'] == $identifier) 
			{
                return $definition;
            }
        }
        
        return null;
    }
    
    /**
     * Get a Content block by its identifier
     *
     * @param string $identifier
     * @return ContentBlock
     */
    public function getBlockByIdentifier($identifier) 
	{
        foreach ($this->ContentBlocks as $contentBlock) 
		{
            if ($contentBlock->identifier == $identifier) 
			{
                return $contentBlock;
            }
        }

        return null;
    }
    
	/**
     * Initialise the Content blocks for rendering
     *
     * Does not load up Content blocks/current versions at all - use
     * loadAllContentBlocksForRender() to load all of the data in one query.
     *
     * @see loadAllContentBlocksForRender()
     * @param string $lang
     */
    public function initialiseForRender($lang) 
	{
        $this->setCurrentLang($lang);
    }
    
	/**
     * Load Content blocks and current versions for rendering
     */
    public function loadAllContentBlocksForRender() 
	{
        $lang = $this->getCurrentLang();
        $contentBlocks = ContentBlockTable::getInstance()->loadAllCurrentVersions($this->id, $lang);
        
        foreach ($contentBlocks as $contentBlock) 
		{
            // We have to link the ContentBlock back to this group - it needs to know about the group for its definition
            $contentBlock->ContentGroup = $this;
            
            // We have constructed the query so that Versions just contains the current version
            $currentContentBlockVersion = $contentBlock->Versions->getFirst();
            
            // The ContentBlockVersion needs to be linked back to the ContentBlock, as it gets its definitions from there
            $currentContentBlockVersion->ContentBlock = $contentBlock;
            $contentBlockLang = $contentBlock->getCurrentLang();
            
            // By setting this, the ContentBlock will not need to do an additional DB query to load its current version.
            $contentBlock->setCurrentVersionsCache($currentContentBlockVersion, $contentBlockLang);
        }
        
        $this->ContentBlocks = $contentBlocks;
    }
    
	/**
     * Render a Content block
     *
     * @param string $identifier
     * @param array $extraParams
     * @return string
     */
    public function renderContent($identifier, $extraParams = array()) 
	{
        if (!$contentBlock = $this->getBlockByIdentifier($identifier)) 
		{
    		return '';
    	}
    	
    	if (!$contentBlockVersion = $contentBlock->getCurrentVersion()) 
		{
    		return '';
    	}

    	$contentBlockVersion->mergeParameters($extraParams);

        if (siteManager::getInstance()->getRenderFromRequest()) 
		{
            // we are in preview mode - render from the request
            $request = sfContext::getInstance()->getRequest();
            
            return $contentBlockVersion->getContentBlockType()->renderFromRequest($request);
        } 
		else 
		{
            return $contentBlockVersion->getContentBlockType()->render();
        }
    }
    
	/**
	 * Delete this Content group and all associated Content
	 *
	 * @param Doctrine_Connection $conn
	 */
	public function delete(Doctrine_Connection $conn = null) 
	{
	    foreach ($this->ContentBlocks as $contentBlock) 
		{
	        // delete all of the ContentBlock versions
	        $allVersions = $contentBlock->Versions;
	        foreach ($allVersions as $version) 
			{
	            $version->delete();
	            $version->free();
	        }

	        // delete the current version stuff
	    	$allCVersions = $contentBlock->CurrentVersions;
	        foreach ($allCVersions as $cVersion) 
			{
	            $cVersion->delete();
	            $cVersion->free();
	        }

	        // finally, delete the ContentBlock itself
	        $contentBlock->delete();
            $contentBlock->free();
	    }

	    parent::delete($conn);
	}
}
